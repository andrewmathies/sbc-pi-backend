package main

import (
	"fmt"
	"net"
	"net/http"
	"net/http/httputil"
	"bytes"
	"strconv"
	"strings"
	"io"
	"io/ioutil"
	"encoding/json"
	"encoding/csv"
	"os"
)


// Structs----------------------------------------------------------------

type AddMsg struct {
	Header string `json:"header"`
	ID string `json:"id"`
	BeanID string `json:"beanID"`
}

type RemoveMsg struct {
	Header string `json:"header"`
	ID string `json:"id"`
}

type UpdateMsg struct {
	Header string `json:"header"`
	Version string `json:"version"`
	ID string `json:"id"`
}

// HTTP Endpoints---------------------------------------------------------

func formatRequest(r *http.Request) {
	requestDump, err := httputil.DumpRequest(r, true)
	checkError("couldnt format http request", err)
	log(string(requestDump))
}

var piConn net.Conn

func routeToPi(r io.Reader) {
	if piConn != nil {
		body, err := ioutil.ReadAll(r)
		checkError("routeToPi, reading body", err)
	
		readBuf := bytes.NewBuffer(body)
		piConn.Write(readBuf.Bytes())
	}
}

func updateVersion(w http.ResponseWriter, r *http.Request) {
	log("update version endpoint hit")	
	formatRequest(r)

	var copyBuf bytes.Buffer
	tee := io.TeeReader(r.Body, &copyBuf)
	
	body, parseError := ioutil.ReadAll(tee)
	checkError("grabbing raw data from response body", parseError)

	msg := UpdateMsg{}
	marshalErr := json.Unmarshal(body, &msg)
	checkError("parsing json from raw data", marshalErr)
	
	routeToPi(&copyBuf)

	file, err := os.OpenFile(csvPath, os.O_RDONLY, 0666)
	checkError("cannot open file", err)

	reader := csv.NewReader(file)

	var units [][]string

	for {
		record, err := reader.Read()
		
		if err == io.EOF {
			break
		}
		checkError("reading csv", err)

		if record[0] == msg.ID {
			record[1] = msg.Version
		}
		
		units = append(units, record)
	}

	deleteErr := os.Remove(csvPath)
	checkError("deleting csv file", deleteErr)

	newFile, createErr := os.Create(csvPath)
	checkError("creating csv file", createErr)
	defer newFile.Close()

	writer := csv.NewWriter(newFile)
	defer writer.Flush()

	for _, line := range units {
		err = writer.Write(line)
		checkError("write to file, update endpoint", err)		
	}

	log("updateVersion written to disk")
}


func addUnit(w http.ResponseWriter, r *http.Request) {
	log("add unit endpoint hit")
	formatRequest(r)

	var copyBuf bytes.Buffer
	tee := io.TeeReader(r.Body, &copyBuf)

	body, parseError := ioutil.ReadAll(tee)
	checkError("grabbing raw data from response body", parseError)

	msg := AddMsg{}
	marshalErr := json.Unmarshal(body, &msg)
	checkError("parsing json from raw data", marshalErr)
	
	routeToPi(&copyBuf)

	file, err := os.OpenFile(csvPath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
	checkError("opening csv file", err)
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	writer.Write([]string{ msg.ID, "", msg.BeanID })
	log("add unit change written to disk")
}

func removeUnit(w http.ResponseWriter, r *http.Request) {
	log("remove unit endpoint hit")
	formatRequest(r)

	var copyBuf bytes.Buffer
	tee := io.TeeReader(r.Body, &copyBuf)

	body, parseError := ioutil.ReadAll(tee)
	checkError("grabbing raw data from response body", parseError)

	msg := RemoveMsg{}
	marshalErr := json.Unmarshal(body, &msg)
	checkError("parsing json from raw data", marshalErr)
	
	routeToPi(&copyBuf)

	file, err := os.OpenFile(csvPath, os.O_RDONLY, 0666)
	checkError("opening csv file", err)

	reader := csv.NewReader(file)

	var units [][]string

	for {
		record, err := reader.Read()
		
		if err == io.EOF {
			break
		}
		checkError("remove unit, read csv", err)

		if record[0] != msg.ID {	
			units = append(units, record)
		}
	}

	deleteErr := os.Remove(csvPath)
	checkError("deleting csv file, remove unit", deleteErr)	

	newFile, createErr := os.Create(csvPath)
	checkError("creating csv file, remove unit", createErr)
	defer newFile.Close()

	writer := csv.NewWriter(newFile)
	defer writer.Flush()

	for _, line := range units {
		writeErr := writer.Write(line)
		checkError("write csv file, remove unit", writeErr)
	}

	log("remove unit change written to disk")
}

func log(message string) {
	fmt.Println(message + "\n")
}

func checkError(message string, err error) {
	if err != nil {
		fmt.Println("ERROR: " + message)
		fmt.Println(err)
		fmt.Println("")
	}
}


func setupRoutes() {
	http.Handle("/", http.FileServer(http.Dir("static/")))
	http.HandleFunc("/sbc/updateVersion", updateVersion)
	http.HandleFunc("/sbc/addUnit", addUnit)
	http.HandleFunc("/sbc/removeUnit", removeUnit)
	
	err := http.ListenAndServe(":80", nil)
	checkError("http server crashed", err)
}

func handleConnection(conn net.Conn) {
	buf := make([]byte, 128)
	
	reqLen, err := conn.Read(buf)
	checkError("couldnt read tcp message from client", err)

	log("established tcp connection")
	log("reqLen: " + strconv.Itoa(reqLen))

	file, openErr := os.OpenFile(csvPath, os.O_RDONLY, 0666)
	checkError("opening csv file, tcp connection established", openErr)
	defer file.Close()
	reader := csv.NewReader(file)

	for {
		line, readErr := reader.Read()

		if readErr == io.EOF {
			break
		}
		checkError("reading csv file, tcp connection established", readErr)

		lineString := strings.Join(line, ",")
		log("read: " + lineString)

		_, tcpErr := conn.Write([]byte(lineString))
		checkError("sending unit info to new tcp connection", tcpErr)
	}

	piConn = conn
}

func tcpServer() {
	l, err := net.Listen("tcp", "172.31.41.193:3000")
	checkError("couldnt open tcp socket", err)

	defer l.Close()
	
	log("tcp server listening on port 3000")

	for {
		conn, err := l.Accept()
		checkError("trouble establishing connection", err)
		go handleConnection(conn)
		defer conn.Close()
	}
}

var csvPath string

func main() {
	log("started server\n")
	csvPath = "/home/ec2-user/server/static/sbc/versions.csv"
	go tcpServer()
	setupRoutes()
}
