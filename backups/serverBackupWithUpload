package main

import (
	"fmt"
	"net"
	"net/http"
	"net/http/httputil"
	"bytes"
	"strconv"
	"io/ioutil"
)

/*
func uploadFile(w http.ResponseWriter, r *http.Request) {
	fmt.Println("File Upload Endpoint Hit")

    // Parse our multipart form, 10 << 20 specifies a maximum
    // upload of 10 MB files.
    r.ParseMultipartForm(10 << 20)
    // FormFile returns the first file for the given key `myFile`
    // it also returns the FileHeader so we can get the Filename,
    // the Header and the size of the file
    file, handler, err := r.FormFile("versionFile")
    if err != nil {
        fmt.Println("Error Retrieving the File")
        fmt.Println(err)
        return
    }
    
    defer file.Close()
    
    fmt.Printf("Uploaded File: %+v\n", handler.Filename)
    fmt.Printf("File Size: %+v\n", handler.Size)
    fmt.Printf("MIME Header: %+v\n", handler.Header)

    // Create a temporary file within our temp directory that follows
    // a particular naming pattern
    tempFile, err := ioutil.TempFile("", handler.Filename)
    if err != nil {
        fmt.Println(err)
    }
    defer tempFile.Close()

    // read all of the contents of our uploaded file into a
    // byte array
    fileBytes, err := ioutil.ReadAll(file)
    if err != nil {
        fmt.Println(err)
    }
    // write this byte array to our temporary file
    tempFile.Write(fileBytes)
    // return that we have successfully uploaded our file!
    fmt.Fprintf(w, "Successfully Uploaded File\n")

    err = os.Rename(tempFile.Name(), "/home/ec2-user/server/static/sbc/versions/" + handler.Filename)

    if err != nil {
    	fmt.Println(err)
    }
}
*/

func formatRequest(r *http.Request) {
	requestDump, err := httputil.DumpRequest(r, true)
	checkError("couldnt format http request", err)
	fmt.Println(string(requestDump))
}

var piConn net.Conn

func routeToPi(r *http.Request) {
	if piConn != nil {
		body, err := ioutil.ReadAll(r.Body)
		checkError("routeToPi, reading body", err)
	
		readBuf := bytes.NewBuffer(body)
		piConn.Write(readBuf.Bytes())
	}
}

func updateVersion(w http.ResponseWriter, r *http.Request) {
	fmt.Println("update version endpoint hit")	
	formatRequest(r)
	routeToPi(r)

/*
	reader := csv.NewReader(r.Body)
	var textContainer [][]string

	for {
		record, err := reader.Read()

		if err == io.EOF {
			break
		}

		checkError("error while reading csv file", err)

		//record = append(record, "\n")
		textContainer = append(textContainer, record)
	}

	fmt.Println("csv file:")
	fmt.Println(textContainer)

	file, err := os.OpenFile("/home/ec2-user/server/static/sbc/versions.csv", os.O_WRONLY, 0666)
	checkError("cannot open file", err)

	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	for _, value := range textContainer {
		err = writer.Write(value)
		checkError("Cannot write to file", err)
	}

	fmt.Println("wrote the new csv")
*/
}


func addUnit(w http.ResponseWriter, r *http.Request) {
	fmt.Println("add unit endpoint hit")
	formatRequest(r)
	routeToPi(r)
}

func removeUnit(w http.ResponseWriter, r *http.Request) {
	fmt.Println("remove unit endpoint hit")
	formatRequest(r)
	routeToPi(r)
}

func checkError(message string, err error) {
	if err != nil {
		fmt.Println(message)
		fmt.Println(err)
	}
}


func setupRoutes() {
	http.Handle("/", http.FileServer(http.Dir("static/")))
	//http.HandleFunc("/sbc/upload", uploadFile)
	http.HandleFunc("/sbc/updateVersion", updateVersion)
	http.HandleFunc("/sbc/addUnit", addUnit)
	http.HandleFunc("/sbc/removeUnit", removeUnit)
	
	err := http.ListenAndServe(":80", nil)
	
	if err != nil {
		fmt.Printf("%v\n", err)
		fmt.Printf("crashed\n")
	}
}

func handleConnection(conn net.Conn) {
	buf := make([]byte, 128)
	
	reqLen, err := conn.Read(buf)
	checkError("couldnt read tcp message from client", err)

	fmt.Println("reqLen: " + strconv.Itoa(reqLen))

	piConn = conn
}

func tcpServer() {
	l, err := net.Listen("tcp", "172.31.41.193:3000")
	checkError("couldnt open tcp socket", err)

	defer l.Close()
	
	fmt.Println("tcp server listening on port 3000")

	for {
		conn, err := l.Accept()
		checkError("trouble establishing connection", err)
		go handleConnection(conn)
		defer conn.Close()
	}
}

func main() {
	fmt.Printf("started server\n")
	go tcpServer()
	setupRoutes()
}
